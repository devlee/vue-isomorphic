import fs from 'fs';
import path from 'path';
import Koa from 'koa';
import Bigpige from 'koa-bigpipe';
import Router from 'koa-router';
import serve from 'koa-static';
import favicon from 'koa-favicon';
import lruCache from 'lru-cache';
import serialize from 'serialize-javascript';
import * as vueServerRenderer from 'vue-server-renderer';

import setupDevServer from './config/webpack/setup-dev-server';

/**
 * resolve
 *
 * help function
 */
const resolve = file => path.resolve(__dirname, file);

const app = new Koa();
const router = new Router();
const isProd = process.env.NODE_ENV === 'production';
const port = process.env.PORT || 5566;

/**
 * html
 *
 * generated by html-webpack-plugin
 */
let html;
/**
 * renderer
 *
 * created from the webpack-generated server bundle
 */
let renderer;

process.env.VUE_ENV = 'server';

function createRenderer(bundle) {
  return vueServerRenderer.createBundleRenderer(bundle, {
    cache: lruCache({
      max: 1000,
      maxAge: 1000 * 60 * 15,
    }),
  });
}

function parseIndex(template) {
  const contentMarker = '<!-- APP -->';
  const i = template.indexOf(contentMarker);
  return {
    head: template.slice(0, i),
    tail: template.slice(i + contentMarker.length),
  };
}

if (isProd) {
  // in production: create server renderer and index HTML from real fs
  renderer = createRenderer(fs.readFileSync(resolve('./dist/server-bundle.js'), 'utf-8'));
  html = parseIndex(fs.readFileSync(resolve('./dist/index.html'), 'utf-8'));
} else {
  // in development: setup the dev server with watch and hot-reload,
  // and update renderer / index HTML on file change.
  setupDevServer(app, {
    bundleUpdated: (bundle) => {
      renderer = createRenderer(bundle);
    },
    indexUpdated: (index) => {
      html = parseIndex(index);
    },
  });
}

router.get('/dist', serve(resolve('./dist')));
router.get('/service-worker.js', serve(resolve('./dist')));

app
  .use(Bigpige)
  .use(favicon(resolve('public/logo-400.png')))
  .use(serve('.'))
  .use(serve(resolve('/public')))
  .use(router.routes())
  .use(router.allowedMethods())
  .use((ctx, next) => {
    const req = ctx.req;
    const res = ctx.res;

    if (!renderer) {
      res.end('waiting for compilation... refresh in a moment.');
    } else {
      const s = Date.now();
      const context = { url: req.url };
      const renderStream = renderer.renderToStream(context);
      let firstChunk = true;

      if (isProd) {
        /* eslint-disable no-param-reassign */
        ctx.state = 200;
        ctx.set({
          'Access-Control-Allow-Origin': '*',
          'Content-Type': 'text/html;charset=utf-8',
          'Cache-Control': 'no-cache, no-transform',
          Connection: 'keep-alive',
        });
        ctx.body = renderStream;
      }

      ctx.write(html.head);

      renderStream.on('data', (chunk) => {
        if (firstChunk) {
          // embed initial store state
          if (context.initialState) {
            ctx.write(`<script>window.__INITIAL_STATE__=${
              serialize(context.initialState, { isJSON: true })
              }</script>`);
          }

          firstChunk = false;
        }

        if (!isProd) {
          ctx.write(chunk);
        }
      });

      renderStream.on('end', () => {
        ctx.end(html.tail);
        console.log(`whole request: ${Date.now() - s}ms`);
      });

      renderStream.on('error', (err) => {
        console.error(`error during render : ${req.url}`);
        console.error(err);
        if (err && err.code === '404') {
          res.statusCode = 404;
          res.end('404 | Page Not Found');
        } else {
          // Render Error Page or Redirect
          res.statusCode = 500;
          ctx.end('Internal Error 500');
        }
      });
    }

    next();
  })
  .listen(port, () => {
    console.log(`server started at http://localhost:${port}`);
  });
